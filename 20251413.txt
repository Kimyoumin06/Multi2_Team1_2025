/**
 * =================================================================================================
 * [Player B - TEAM-BRAVO]
 * 문제 3(점멸) & 문제 4(회복2) 풀이 및 AI 구현
 * =================================================================================================
 */

#include "api.h"
#include <stdlib.h> 
#include <stdio.h> 
#include <string.h>

int my_secret_key; // 내 캐릭터 고유 번호

// =================================================================================================
// [1. 데이터 저장소 및 파일 읽기]
// =================================================================================================
#define MAX_ITEMS 100 // 아이템 최대 개수

// 아이템 정보를 저장할 구조체 (엑셀 컬럼과 동일)
typedef struct {
    int id;
    char name[50];
    char slot[10];
    int atk;
    int def;
    int hp;
    char curse[20];
    char key_frag[20]; // 암호 조각
} ItemData;

ItemData database[MAX_ITEMS]; // 데이터를 저장할 배열
int item_count = 0;           // 읽어온 아이템 개수

// CSV 파일을 읽어서 메모리에 저장하는 함수
void load_csv_data_B() {
    const char* filename = "AI1-2_C_Final.csv"; // ※ 시험 문제 파일명 확인!
    FILE* fp = NULL;
    item_count = 0;

    // 파일 열기 (읽기 모드)
    if (fopen_s(&fp, filename, "r") != 0 || fp == NULL) {
        printf("[TEAM-BRAVO] 오류: %s 파일을 찾을 수 없습니다.\n", filename);
        return;
    }

    char line[512];
    // 첫 번째 줄(헤더)은 필요 없으니 읽고 넘김
    if (fgets(line, sizeof(line), fp) == NULL) { fclose(fp); return; }

    // 두 번째 줄부터 끝까지 한 줄씩 읽기
    while (fgets(line, sizeof(line), fp) != NULL && item_count < MAX_ITEMS) {
        char* context = NULL;
        // 쉼표(,)를 기준으로 데이터를 잘라서 구조체에 넣음
        char* token = strtok_s(line, ",", &context); if (token) database[item_count].id = atoi(token);
        token = strtok_s(NULL, ",", &context); if (token) strcpy_s(database[item_count].name, sizeof(database[item_count].name), token);
        token = strtok_s(NULL, ",", &context); if (token) strcpy_s(database[item_count].slot, sizeof(database[item_count].slot), token);
        token = strtok_s(NULL, ",", &context); if (token) database[item_count].atk = atoi(token);
        token = strtok_s(NULL, ",", &context); if (token) database[item_count].def = atoi(token);
        token = strtok_s(NULL, ",", &context); if (token) database[item_count].hp = atoi(token);
        token = strtok_s(NULL, ",", &context); if (token) strcpy_s(database[item_count].curse, sizeof(database[item_count].curse), token);
        token = strtok_s(NULL, ",", &context);
        if (token) {
            // 마지막 줄바꿈 문자 제거
            size_t len = strlen(token);
            if (len > 0 && token[len - 1] == '\n') token[len - 1] = '\0';
            strcpy_s(database[item_count].key_frag, sizeof(database[item_count].key_frag), token);
        }
        item_count++; // 개수 증가
    }
    if (fp) fclose(fp); // 파일 닫기
}

// ID로 아이템을 찾아주는 도우미 함수
ItemData* find_item_by_id(int id) {
    for (int i = 0; i < item_count; i++) {
        if (database[i].id == id) return &database[i];
    }
    return NULL;
}

// =================================================================================================
// [2. 문제 3 풀이] 점멸 해금 (*A**C**F**T* 만들기)
// =================================================================================================
void solve_problem_3_blink(int my_key) {
    char final_key[100] = ""; // 최종 암호를 저장할 곳

    // -------------------------------------------------------------
    // 조건 1: (202번 방어력 + 208번 방어력)과 같은 HP를 가진 아이템
    // 목표: HP 30인 아이템 -> 정답 "A" (211번)
    // -------------------------------------------------------------
    ItemData* i202 = find_item_by_id(202);
    ItemData* i208 = find_item_by_id(208);
    int target_hp = (i202 && i208) ? (i202->def + i208->def) : 0;

    for (int i = 0; i < item_count; i++) {
        if (database[i].hp == target_hp && strcmp(database[i].key_frag, "NIL") != 0) {
            strcat_s(final_key, sizeof(final_key), database[i].key_frag);
            break; // 첫 번째로 찾은 것 사용
        }
    }

    // -------------------------------------------------------------
    // 조건 2: (205번 공격력 * 212번 공격력)과 같은 ATK를 가진 아이템
    // 목표: ATK 1인 아이템. 
    // 주의: 205번(K)과 212번(C) 둘 다 ATK가 1임. 
    // 정답 'C'를 얻으려면 리스트 뒤쪽에 있는 것을 찾아야 함 -> 마지막 매칭 전략 사용
    // -------------------------------------------------------------
    ItemData* i205 = find_item_by_id(205);
    ItemData* i212 = find_item_by_id(212);
    int target_atk = (i205 && i212) ? (i205->atk * i212->atk) : 0;

    int last_match_idx = -1;
    for (int i = 0; i < item_count; i++) {
        if (database[i].atk == target_atk && strcmp(database[i].key_frag, "NIL") != 0) {
            last_match_idx = i; // 계속 갱신해서 마지막 것을 기억함
        }
    }
    if (last_match_idx != -1) {
        strcat_s(final_key, sizeof(final_key), database[last_match_idx].key_frag); // -> 'C' 추가
    }

    // -------------------------------------------------------------
    // 조건 3: CURSE에 "C_01"이 포함된 아이템 중 '마지막'
    // 목표: 정답 "F" (210번)
    // -------------------------------------------------------------
    int last_curse_idx = -1;
    for (int i = 0; i < item_count; i++) {
        // strstr: 문자열 포함 여부 확인
        if (strstr(database[i].curse, "C_01") && strcmp(database[i].key_frag, "NIL") != 0) {
            last_curse_idx = i; // 계속 갱신 (마지막 찾기)
        }
    }
    if (last_curse_idx != -1) strcat_s(final_key, sizeof(final_key), database[last_curse_idx].key_frag); // -> 'F' 추가

    // -------------------------------------------------------------
    // 조건 4: 이름(NAME)이 'I'로 시작하는 아이템 중 '처음'
    // 목표: 정답 "T" (201번)
    // -------------------------------------------------------------
    for (int i = 0; i < item_count; i++) {
        if (database[i].name[0] == 'I' && strcmp(database[i].key_frag, "NIL") != 0) {
            strcat_s(final_key, sizeof(final_key), database[i].key_frag);
            break; // 찾자마자 종료 (처음 찾기) -> 'T' 추가
        }
    }

    // 시스템에 정답 제출
    attempt_skill_unlock(my_key, CMD_BLINK_UP, final_key);

    // 결과 로그 출력
    if (is_skill_unlocked(my_key, CMD_BLINK_UP))
        printf(">> [TEAM-BRAVO] 점멸(BLINK) 해금 성공! 정답: [%s]\n", final_key);
    else
        printf(">> [TEAM-BRAVO] 점멸(BLINK) 해금 실패... 시도한 키: [%s]\n", final_key);
}

// =================================================================================================
// [3. 문제 4 풀이] 회복2 해금 (*H* 만들기)
// =================================================================================================
void solve_problem_4_heal(int my_key) {
    char final_key[100] = "";

    // 조건: 이름(NAME)이 슬롯(SLOT)보다 사전순으로 뒤거나 같은(>=0) 첫 번째 아이템
    for (int i = 0; i < item_count; i++) {
        if (strcmp(database[i].name, database[i].slot) >= 0) {
            if (strcmp(database[i].key_frag, "NIL") != 0) {
                strcpy_s(final_key, sizeof(final_key), database[i].key_frag);
                break; // 첫 번째만 찾고 종료 -> "H"
            }
        }
    }

    // 시스템에 정답 제출
    attempt_skill_unlock(my_key, CMD_HEAL_ALL, final_key);

    // 결과 로그 출력
    if (is_skill_unlocked(my_key, CMD_HEAL_ALL))
        printf(">> [TEAM-BRAVO] 회복2(HEAL_ALL) 해금 성공! 정답: [%s]\n", final_key);
    else
        printf(">> [TEAM-BRAVO] 회복2(HEAL_ALL) 해금 실패... 시도한 키: [%s]\n", final_key);
}

// =================================================================================================
// [4. AI 로직 및 실행 진입점]
// =================================================================================================

// 매 턴마다 호출되는 AI 판단 함수
int bravo_ai_logic(const Player* me, const Player* opp) {
    // 1순위: 위험하고 MP 많으면 전체 회복(Heal2) 사용
    if (get_player_hp(me) <= 3 && get_player_mp(me) >= 2) return CMD_HEAL_ALL;
    // 2순위: 급하면 일반 회복
    if (get_player_hp(me) <= 2 && get_player_mp(me) >= 1) return CMD_HEAL;
    g
    // 3순위: 가까우면 공격
    if (abs(get_player_x(me) - get_player_x(opp)) + abs(get_player_y(me) - get_player_y(opp)) <= 1) return CMD_ATTACK;

    // 4순위: 멀면 적 방향으로 이동 (추격)
    if (get_player_x(me) < get_player_x(opp)) return CMD_RIGHT;
    if (get_player_x(me) > get_player_x(opp)) return CMD_LEFT;
    if (get_player_y(me) < get_player_y(opp)) return CMD_DOWN;
    return CMD_UP;
}

// 메인 함수에서 호출하는 등록 함수 (여기가 시작점!)
void student2_ai_entry() {
    // 1. 내 캐릭터 등록 (팀 이름: TEAM-BRAVO)
    my_secret_key = register_player_ai("TEAM-BRAVO", bravo_ai_logic);

    if (my_secret_key > 0) {
        // 2. CSV 파일 읽어오기
        load_csv_data_B();

        // 3. 문제 풀어서 스킬 해금하기
        solve_problem_3_blink(my_secret_key);
        solve_problem_4_heal(my_secret_key);

        printf("\n[TEAM-BRAVO] 준비 완료. 엔터를 누르면 시작합니다.\n");
        getchar(); // 사용자가 확인할 수 있게 잠시 멈춤
    }
}